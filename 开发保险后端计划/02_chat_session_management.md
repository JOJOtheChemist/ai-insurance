# AI 保典 会话管理与历史记录实现方案

## 1. 会话架构设计 (基于现有 Kode-SDK)

当前后端采用了基于文件系统的持久化方案，能够完美支持“不同用户”的“独立对话历史”。

### 1.1 存储目录结构
所有聊天记录均存储在 `.kode` 目录下，按以下层级组织：
```text
.kode/
  └── [userId]/             # 销售人员 ID (如: demon)
      └── [sessionId]/      # 客户对话会话 ID (如: session-173...)
          ├── meta.json     # 会话元数据 (标题、创建时间、所属用户)
          └── runtime/
              └── messages.json # 完整的聊天信息列表
```

### 1.2 用户隔离逻辑
- **后端识别**: 在 `/api/chat` 请求时，后端通过 JWT 提取 `userId`，并将消息路由到该用户专属的 `.kode/[userId]` 目录。
- **Agent 实例隔离**: 每个会话会启动一个独立的 Agent 实例，命名规则为 `${userId}:${sessionId}:${agentId}`，确保不同用户的对话上下文互不干扰。

---

## 2. 前端历史记录对接 (关键序号步骤)

### 2.1 基础数据获取
前端需要通过以下接口获取历史列表，并将其渲染到 `HistoryDrawer` 中。

**接口**: `GET /api/sessions`
**返回示例**:
```json
{
  "ok": true,
  "sessions": [
    {
      "id": "session-1734823200000",
      "name": "王志远 - 重疾险咨询",
      "messagesCount": 12,
      "updatedAt": "2025-12-21T14:30:00.000Z",
      "userId": "demon",
      "messages": [...] 
    }
  ]
}
```

### 2.2 历史记录查看流程
1. **加载列表**: 当用户打开“历史会话”抽屉时，前端调用 `GET /api/sessions`。
2. **切换会话**: 用户点击某个历史卡片后：
   - 清空当前 `messages` 数组。
   - 将 `sessionIdRef.current` 更新为该历史会话的 `id`。
   - 调用 `GET /api/sessions/{id}` 获取详细消息并展示。
3. **继续对话**: 用户发送新消息时，后端会根据现有的 `sessionId` 自动加载 `.kode` 中的上下文。

---

## 3. 字段说明与数据库同步

虽然目前的会话存储在文件系统中，但为了支持销售人员的“客户管理”面板，我们需要将核心信息同步到数据库。

### 3.1 会话元数据同步 (建议扩展)
| 序号 | 字段名 | 说明 | 来源 |
| :--- | :--- | :--- | :--- |
| 1 | `session_id` | 唯一标识 | `sessionIdRef` |
| 2 | `title` | 会话标题 (如：客户名+主题) | `meta.json` |
| 3 | `client_id` | 归属客户 | 需在创建会话时指定 |

### 3.2 自动同步逻辑
- 当 AI 在对话中完成一次回复后，后端会读取 `meta.json` 并检查是否需要同步到 `clients` 表的“最后跟进时间”或“谈话简报”。

---

## 4. 后续优化序号
1. **[前端]** 修改 `HistoryDrawer`，增加 `useEffect` 调用 `/api/sessions`。
2. **[后端]** 在 `multiUserStorage.writeMeta` 中增加 Hook，当标题更新时同步到主数据库。
3. **[清理]** 增加定时任务，清理超过 30 天的无效/冗余会话文件。

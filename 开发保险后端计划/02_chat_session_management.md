# AI 保典 会话管理与历史记录实现方案

## 1. 会话架构设计 (基于现有 Kode-SDK)

当前后端采用了基于文件系统的持久化方案，能够完美支持“不同用户”的“独立对话历史”。

### 1.1 存储目录结构 (保持原有)
聊天记录保持扁平结构，存储在 `.kode` 目录下。这种结构简单稳定，支持“未归属客户”的自由对话。
```text
.kode/
  └── [userId]/             # 销售人员 ID (如: demon)
      └── [sessionId]/      # 具体的会话文件夹
          ├── meta.json     # 包含：标题、创建时间、客户标记(可选)
          └── runtime/
              └── messages.json # 聊天记录
```

### 1.2 用户隔离逻辑
- **后端识别**: 在 `/api/chat` 请求时，后端通过 JWT 提取 `userId`，并将消息路由到该用户专属的 `.kode/[userId]` 目录。
- **Agent 实例隔离**: 每个会话会启动一个独立的 Agent 实例，命名规则为 `${userId}:${sessionId}:${agentId}`，确保不同用户的对话上下文互不干扰。

---

## 2. 前端历史记录对接 (关键序号步骤)

### 2.1 基础数据获取与过滤
系统通过 **数据库 (PostgreSQL)** 进行逻辑关联，而不是依赖文件夹深度。

**接口**: `GET /api/v1/clients/{clientId}/sessions`
**实现逻辑**:
1. 查询数据库 `chat_sessions` 表中所有 `client_id` 等于该客户的消息记录。
2. 返回对应的 `sessionId` 列表及其元数据。

**场景说明**:
- **新对话**: 初始存储在 `.kode/[userId]/[sessionId]`。
- **关联客户**: 一旦 AI 识别出客户或手动选定客户，在数据库中写入 `(sessionId, clientId)` 映射关系。
- **无客户对话**: 数据库中 `client_id` 为空，依然可以通过全局列表查看。

---

## 3. 字段说明与数据库同步

虽然目前的会话存储在文件系统中，但为了支持销售人员的“客户管理”面板，我们需要将核心信息同步到数据库。

### 3.1 会话元数据同步 (建议扩展)
| 序号 | 字段名 | 说明 | 来源 |
| :--- | :--- | :--- | :--- |
| 1 | `session_id` | 唯一标识 | `sessionIdRef` |
| 2 | `title` | 会话标题 (如：客户名+主题) | `meta.json` |
| 3 | `client_id` | 归属客户 | 需在创建会话时指定 |

### 3.2 自动同步逻辑
- 当 AI 在对话中完成一次回复后，后端会读取 `meta.json` 并检查是否需要同步到 `clients` 表的“最后跟进时间”或“谈话简报”。

---

## 4. 后续优化序号
1. **[前端]** 修改 `HistoryDrawer`，增加 `useEffect` 调用 `/api/sessions`。
2. **[后端]** 在 `multiUserStorage.writeMeta` 中增加 Hook，当标题更新时同步到主数据库。
3. **[清理]** 增加定时任务，清理超过 30 天的无效/冗余会话文件。

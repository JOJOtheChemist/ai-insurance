# 保险搜索工具设计教程与决策指南

## 1. 核心问题回顾

在设计 AI 保险顾问的搜索工具时，我们面临两个核心架构选择：
*   **现有的 `fs_grep`**：它是纯前端/本地工具，用于搜文件内容。
*   **规划的 `insurance_search`**：它是业务工具，通常用于搜数据库。

## 2. 为什么需要后端 API？

虽然 `fs_grep` 可以直接搜本地文件，但对于保险业务，**强烈建议使用 PostgreSQL + 后端 API**。

### 现有工具 (`fs_grep`) 的局限性
*   **原理**：`fs_grep` = 读取文件 -> 内存正则匹配。
*   **适用场景**：代码库搜索、小型配置文档搜索。
*   **不适合业务数据**：一旦产品数量达到几百个，或者文本量很大，它需要把所有文件读入内存才能搜索，效率极低且不具备业务逻辑（如按“险种”筛选）。

### 业务搜索工具的设计
*   **架构**：`Agent` -> `Tool (HTTP Request)` -> `Backend API (FastAPI)` -> `PostgreSQL`
*   **优势**：利用数据库的索引能力，毫秒级返回结果，且只返回必要的数据，节省 Agent 上下文。

## 3. 关于 JSON 关键词搜索的设计

保险产品中大量的非标准字段（如“等待期规则”、“特殊病种定义”）存储在 `extend_info` (JSON) 字段中。

### 推荐方案：JSON 转文本搜索 (Cast to Text)
不要让 Agent 去学习复杂的 JSON 查询语法（如 `extend_info->>'waiting_period'`），直接让它搜关键词。

**后端 SQL 实现：**
```sql
SELECT product_name 
FROM insurance_product 
WHERE extend_info::text ILIKE '%牙科%';
```

*   **对 Agent 来说**：它只需要输入 "牙科"，不用管这个词是在标题里还是在 JSON 结构深处。
*   **实现成本**：极低，且效果很好。

## 4. 关于对比工具 (Comparison Tool)

### 它是必须的吗？
**初期不是必须的，但后期是优化的关键。**

*   **阶段一（仅有搜索工具）**：
    *   Agent 动作：`search(产品A)` -> 获得 2000 字详情 -> `search(产品B)` -> 获得 2000 字详情。
    *   结果：上下文消耗 4000 字。
*   **阶段二（引入对比工具）**：
    *   Agent 动作：`compare(产品A, 产品B, fields=['等待期', '费率'])`。
    *   结果：只返回几百字的关键差异，上下文节省 90%。

**结论**：先做搜索，等 Agent 变得“啰嗦”或“健忘”时，再加对比工具。

---

## 5. 假如我们只用 TXT 文件 (非结构化数据)？

如果你不想维护数据库，想把所有保险产品存为一个个 `.txt` 文件，**这也是可行的**，特别是对于 AI Agent 场景。

### 纯文本方案 (RAG 雏形)

**架构**：
*   存储：`/data/products/产品A.txt`, `/data/products/产品B.txt`
*   工具：直接复用或魔改 `fs_grep`。

**优势**：
1.  **无需数据库维护**：所见即所得，更新产品就是改文件。
2.  **保留原始语境**：TXT 保留了条款的段落结构，AI 读起来更容易理解上下文。

**劣势**：
1.  **无法精确筛选**：你没法写 SQL 说 `WHERE age_limit > 60`。Agent 只能搜文本。
2.  **上下文不可控**：如果一个 txt 有 2万字，Agent 为了回答一个小问题（如“犹豫期几天”），不得不读取整个文件，瞬间撑爆上下文窗口（或消耗大量 Token 费用）。

### 如何优化纯文本方案？
如果你坚持用 TXT，必须配合 **切片 (Chunking)** 策略：
1.  不要让 Agent 直接读整个 TXT。
2.  工具应该支持“只读前 50 行”或者“只读包含‘犹豫期’的段落”。

**修改后的 `grep` 工具逻辑**：
*   输入：`grep(pattern="犹豫期", files=["产品A.txt"])`
*   输出：不是返回文件名，而是返回 **匹配行及其前后 5 行 (Context Window)**。

这样就手动实现了一个简易的 RAG（检索增强生成）系统。

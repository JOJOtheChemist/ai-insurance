# PostgreSQL 深度搜索工具设计方案 & GIN 索引分析

## 1. 核心结论

### Q: 是否需要建立 GIN 索引？
**A: 必须建立。**
如果不建立索引，要在 JSON 字段中搜索 "分红"、"犹豫期" 等关键词，数据库必须**逐行扫描**所有产品的完整 JSON 内容并转为文本匹配。随着产品数量和 JSON 复杂度的增加，查询速度会从毫秒级堕落到秒级甚至更慢。
- **推荐索引方案**: `pg_trgm` (以支持模糊查询 `ILIKE`)。
- **索引指令**: `CREATE INDEX idx_extend_info_trgm ON insurance_product USING GIN ((extend_info::text) gin_trgm_ops);`

---

## 2. 深度搜索与上下文节省设计方案

为了满足“节省上下文”但又能“搜索任何细节”的需求，简单的全文检索是不够的（因为返回整段 JSON 依然太长）。我们需要一个 **"定位 + 提取"** 的两步走策略。

### 2.1 数据库层设计

我们利用 PostgreSQL 强大的 JSONB 能力和函数生态。

#### 表结构 (简化)
```sql
CREATE TABLE insurance_product (
    id SERIAL PRIMARY KEY,
    name TEXT,
    extend_info JSONB -- 存放所有非标、深度细节 (分红、病种、免责等)
);
```

#### 关键技术：智能片段提取 (Snippet Extraction)
为了节省上下文，Agent 不应该拿到整个 `extend_info`。我们需要一个数据库函数（或应用层逻辑），能够根据关键词，**只返回包含该关键词的 JSON 节点**。

**关于上下文长度的策略：**
*   **默认为“对象级”上下文**：不仅仅返回 key-value，而是返回包含该命中节点的**整个父级 JSON 对象**。
    *   *例如*: 搜 "英式分红"，不只返回 `"value": "英式分红"`, 而是返回整个分红策略对象 `{ "type": "英式分红", "history": "...", "demo": "..." }`。
*   **可配置参数**: 增加 `snippet_level` 参数 (e.g., 'tight' | 'object' | 'extended')，让 Agent 或系统根据 Token 预算动态调整。
    *   如果只是想确认“有没有”，用 tight (节省)。
    *   如果是在做详细对比，用 object (信息全)。

**方案 A: PL/pgSQL 搜索函数 (推荐，数据库内完成，传输量最小)**
我们可以编写一个辅助函数，它接受 JSONB 和关键词，递归遍历并返回匹配的 Key-Value 对及其上下文。

*示例逻辑:*
1. **输入**: JSONB Data, Keyword "分红", Level "Object"
2. **逻辑**: 遍历 JSON 树，找到命中节点，向上回溯一级。
3. **输出**: `{"path": "benefits.dividend_policy", "context": { "policy_name": "英式分红", "description": "本产品包含..." }}`

### 2.2 Agent 工具链设计

我们设计三个分层工具，让 Agent 像人类一样由浅入深地探索。

#### 工具 1: `search_knowledge` (全库广搜)
*   **用途**: 用户问“有没有能保分红的产品？”或者“找关注非标准病种的产品”。
*   **参数**: `query` (字符串)
*   **后端实现**:
    1.  **全字段覆盖搜索**: SQL 将同时检索 `product_name`, `description`, 和 `extend_info`。
        ```sql
        WHERE product_name ILIKE '%query%' 
           OR description ILIKE '%query%' 
           OR extend_info::text ILIKE '%query%'
        ```
    2.  **高亮提取**: 针对命中 `extend_info` 的记录，调用上述“查找路径”逻辑，提取 JSON 片段；针对命中 `description` 的记录，截取文本前后由 `pg_trgm` 支持的摘要。
*   **返回给 Agent**:
    ```json
    [
      {
        "id": 101,
        "name": "金佑人生A款",
        "match_snippet": "找到相关信息: { 'bonus_rules': '...每年根据公司经营情况分配红利...' }" 
      },
      {
        "id": 204,
        "name": "尊享e生",
        "match_snippet": "找到相关信息: { 'exclusions': '...非标准体需人工核保...' }"
      }
    ]
    ```
    *(注：这里只返回了极短的 snippet，极大地节省了 Context)*

#### 工具 2: `inspect_details` (定向深挖)
*   **用途**: Agent 看到 ID=101 有分红，想看具体能赔多少钱、分红演示。
*   **参数**: `product_id`, `focus_keys` (数组，如 `["dividend", "payout_table"]`)
*   **功能**:
    *   Agent 可以直接请求获取特定的 JSON 子树。
    *   支持模糊 Key 匹配（例如 Agent 传 `payout`，后端自动找 `payout_high`, `payout_low` 等相关 Key）。
*   **返回**: 仅返回请求的子树结构。

#### 工具 3: `filter_products` (硬指标过滤)
*   **用途**: “我要 60 岁能买的”、“保额大于 50 万的”。
*   **参数**: `age`, `min_sum_assured` 等结构化字段。
*   **功能**: 标准 SQL `WHERE` 过滤。

---

## 3. 实现路线图

1.  **DB 准备**:
    *   启用 `pg_trgm`。
    *   建立 `extend_info::text` 的 GIN 索引。
2.  **后端逻辑**:
    *   实现 `find_json_path(data, keyword)` 逻辑 (Python 递归或 PG 函数均可，Python 开发效率更高)。
    *   在 `search` 接口中，先用 SQL 召回，再用 Python 处理 Snippet 截取。
3.  **Agent Prompt 调优**:
    *   告诉 Agent：*“你可以搜索任何细节，搜索引擎会告诉你它在 JSON 的哪里。看到感兴趣的片段后，用 `inspect` 工具读取完整段落。”*

这样设计，Agent 不会迷失在巨大的 JSON 中，也能精准捕获到用户关心的类似“分红回本”、“非标病种”等微小细节。

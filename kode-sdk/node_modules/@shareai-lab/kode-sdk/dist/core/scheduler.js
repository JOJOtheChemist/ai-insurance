"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentSchedulerHandle = exports.Scheduler = void 0;
class Scheduler {
    constructor() {
        this.tasks = new Map();
        this.stepCounters = new Map();
        this.timers = [];
    }
    every(interval, callback) {
        const ms = this.parseInterval(interval);
        const id = `time-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const task = {
            id,
            type: 'time',
            spec: interval,
            callback,
            enabled: true,
        };
        this.tasks.set(id, task);
        const timer = setInterval(() => {
            if (task.enabled) {
                task.callback({ count: 0, type: 'time', id });
                task.lastRun = Date.now();
            }
        }, ms);
        this.timers.push(timer);
        return this;
    }
    everySteps(steps, callback, targetId) {
        const id = targetId || `step-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const task = {
            id,
            type: 'step',
            spec: steps,
            callback,
            enabled: true,
        };
        this.tasks.set(id, task);
        this.stepCounters.set(id, 0);
        return this;
    }
    daily(time, callback) {
        const id = `daily-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const task = {
            id,
            type: 'daily',
            spec: time,
            callback,
            enabled: true,
        };
        this.tasks.set(id, task);
        this.scheduleDailyTask(task);
        return this;
    }
    weekly(dayTime, callback) {
        const id = `weekly-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        const task = {
            id,
            type: 'weekly',
            spec: dayTime,
            callback,
            enabled: true,
        };
        this.tasks.set(id, task);
        this.scheduleWeeklyTask(task);
        return this;
    }
    notifyStep(targetId) {
        for (const [id, task] of this.tasks) {
            if (task.type === 'step' && (!targetId || id === targetId)) {
                const count = (this.stepCounters.get(id) || 0) + 1;
                this.stepCounters.set(id, count);
                if (count >= task.spec) {
                    task.callback({ count, type: 'step', id });
                    this.stepCounters.set(id, 0);
                    task.lastRun = Date.now();
                }
            }
        }
    }
    stop() {
        for (const timer of this.timers) {
            clearInterval(timer);
        }
        this.timers = [];
        this.tasks.clear();
        this.stepCounters.clear();
    }
    parseInterval(interval) {
        const match = interval.match(/^(\d+)(s|m|h|d)$/);
        if (!match)
            throw new Error(`Invalid interval: ${interval}`);
        const value = parseInt(match[1], 10);
        const unit = match[2];
        switch (unit) {
            case 's':
                return value * 1000;
            case 'm':
                return value * 60 * 1000;
            case 'h':
                return value * 60 * 60 * 1000;
            case 'd':
                return value * 24 * 60 * 60 * 1000;
            default:
                throw new Error(`Unknown unit: ${unit}`);
        }
    }
    scheduleDailyTask(task) {
        const [hours, minutes] = task.spec.split(':').map(Number);
        const now = new Date();
        const target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hours, minutes, 0);
        if (target.getTime() <= now.getTime()) {
            target.setDate(target.getDate() + 1);
        }
        const delay = target.getTime() - now.getTime();
        const timeout = setTimeout(() => {
            if (task.enabled) {
                task.callback({ time: task.spec, type: 'daily', id: task.id });
                task.lastRun = Date.now();
            }
            this.scheduleDailyTask(task);
        }, delay);
        this.timers.push(timeout);
    }
    scheduleWeeklyTask(task) {
        const [day, time] = task.spec.split(' ');
        const [hours, minutes] = time.split(':').map(Number);
        const dayMap = {
            Sun: 0,
            Mon: 1,
            Tue: 2,
            Wed: 3,
            Thu: 4,
            Fri: 5,
            Sat: 6,
        };
        const targetDay = dayMap[day];
        if (targetDay === undefined)
            throw new Error(`Invalid day: ${day}`);
        const now = new Date();
        const target = new Date(now);
        target.setHours(hours, minutes, 0, 0);
        const currentDay = now.getDay();
        let daysUntilTarget = targetDay - currentDay;
        if (daysUntilTarget < 0 || (daysUntilTarget === 0 && target.getTime() <= now.getTime())) {
            daysUntilTarget += 7;
        }
        target.setDate(target.getDate() + daysUntilTarget);
        const delay = target.getTime() - now.getTime();
        const timeout = setTimeout(() => {
            if (task.enabled) {
                task.callback({ time: task.spec, type: 'weekly', id: task.id });
                task.lastRun = Date.now();
            }
            this.scheduleWeeklyTask(task);
        }, delay);
        this.timers.push(timeout);
    }
}
exports.Scheduler = Scheduler;
class AgentSchedulerHandle {
    constructor(scheduler, agentId) {
        this.scheduler = scheduler;
        this.agentId = agentId;
    }
    every(interval, callback) {
        this.scheduler.every(interval, callback);
        return this;
    }
    everySteps(steps, callback) {
        this.scheduler.everySteps(steps, callback, this.agentId);
        return this;
    }
    daily(time, callback) {
        this.scheduler.daily(time, callback);
        return this;
    }
    weekly(dayTime, callback) {
        this.scheduler.weekly(dayTime, callback);
        return this;
    }
}
exports.AgentSchedulerHandle = AgentSchedulerHandle;

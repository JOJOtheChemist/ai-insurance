"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EventBus = void 0;
const types_1 = require("../core/types");
const events_1 = require("events");
const crypto_1 = require("crypto");
class EventBus extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.cursor = 0;
        this.timeline = [];
        this.subscribers = new Set();
    }
    setStore(store, sessionId) {
        this.store = store;
        this.sessionId = sessionId;
    }
    emitEvent(event) {
        const cursor = this.cursor++;
        const eventId = (0, crypto_1.randomUUID)();
        const timestamp = Date.now();
        const fullEvent = { ...event, cursor, eventId, timestamp };
        const timeline = { cursor, event: fullEvent };
        this.timeline.push(timeline);
        // Memory management: keep only last 10k events in memory
        if (this.timeline.length > 10000) {
            this.timeline = this.timeline.slice(-5000);
        }
        // Persist to store if configured
        if (this.store && this.sessionId) {
            this.store.appendEvent(this.sessionId, timeline).catch((err) => {
                // Log error but don't block event emission
                console.error('Failed to persist event:', err);
            });
        }
        // Notify all subscribers
        for (const subscriber of this.subscribers) {
            if (subscriber.accepts(fullEvent.type)) {
                subscriber.push(fullEvent);
            }
        }
        // Emit control plane events
        this.emit(event.type, fullEvent);
        return cursor;
    }
    subscribe(opts) {
        const subscriber = new EventSubscriber(opts?.kinds || types_1.MINIMAL_EVENT_KINDS);
        this.subscribers.add(subscriber);
        // Replay past events if since is specified
        if (opts?.since !== undefined) {
            const past = this.timeline.filter((t) => t.cursor >= opts.since);
            for (const t of past) {
                if (subscriber.accepts(t.event.type)) {
                    subscriber.push(t.event);
                }
            }
        }
        const self = this;
        return {
            [Symbol.asyncIterator]: () => ({
                next: async () => {
                    const event = await subscriber.next();
                    if (!event) {
                        self.subscribers.delete(subscriber);
                        return { done: true, value: undefined };
                    }
                    return { done: false, value: event };
                },
                return: async () => {
                    subscriber.close();
                    self.subscribers.delete(subscriber);
                    return { done: true, value: undefined };
                },
            }),
        };
    }
    getTimeline(since) {
        return since !== undefined ? this.timeline.filter((t) => t.cursor >= since) : this.timeline;
    }
    getCursor() {
        return this.cursor;
    }
    reset() {
        this.cursor = 0;
        this.timeline = [];
        this.subscribers.clear();
    }
}
exports.EventBus = EventBus;
class EventSubscriber {
    constructor(kinds) {
        this.kinds = kinds;
        this.queue = [];
        this.waiting = null;
        this.closed = false;
    }
    accepts(kind) {
        return this.kinds.includes(kind);
    }
    push(event) {
        if (this.closed)
            return;
        if (this.waiting) {
            this.waiting(event);
            this.waiting = null;
        }
        else {
            this.queue.push(event);
        }
    }
    async next() {
        if (this.closed)
            return null;
        if (this.queue.length > 0)
            return this.queue.shift();
        return new Promise((resolve) => {
            this.waiting = resolve;
        });
    }
    close() {
        this.closed = true;
        if (this.waiting) {
            this.waiting(null);
            this.waiting = null;
        }
    }
}

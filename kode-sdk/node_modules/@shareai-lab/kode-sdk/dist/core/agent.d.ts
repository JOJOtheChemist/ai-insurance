import { AgentStatus, AgentInfo, AgentEvent, SubscribeOptions, SnapshotId } from './types';
import { Hooks } from './hooks';
import { Scheduler } from './scheduler';
import { Provider } from '../infra/provider';
import { Store } from '../infra/store';
import { Sandbox } from '../infra/sandbox';
import { Tool } from '../tools/fs';
import { AgentTemplate } from '../tools/task';
export interface AgentOptions {
    sessionId: string;
    provider: Provider;
    store: Store;
    sandbox: Sandbox;
    tools?: Tool[];
    system?: string;
    maxTokens?: number;
    temperature?: number;
    maxConcurrency?: number;
    templateId?: string;
}
export declare class Agent {
    private sessionId;
    private provider;
    private store;
    private sandbox;
    private tools;
    private system?;
    private maxTokens;
    private temperature;
    private maxConcurrency;
    private templateId;
    private messages;
    private state;
    private lastSfpIndex;
    private stepCount;
    private events;
    private hooks;
    private scheduler?;
    private pendingPermissions;
    private interrupted;
    constructor(templateOrOpts: AgentTemplate | AgentOptions, overrides?: Partial<AgentOptions>);
    send(text: string): Promise<string>;
    subscribe(opts?: SubscribeOptions): AsyncIterable<AgentEvent>;
    chat(text: string): AsyncIterable<AgentEvent>;
    reply(text: string): Promise<string>;
    askLLM(text: string, opts?: {
        sessionId?: string;
        provider?: Provider;
        useTools?: boolean;
        system?: string;
    }): Promise<{
        text: string;
        sessionId: string;
    }>;
    interrupt(opts?: {
        note?: string;
    }): Promise<void>;
    decide(permId: string, decision: 'allow' | 'deny', note?: string): Promise<void>;
    snapshot(label?: string): Promise<SnapshotId>;
    fork(sel?: SnapshotId | {
        at?: string;
    }): Promise<Agent>;
    static resume(sessionId: string, opts: AgentOptions & {
        autoRun?: boolean;
        strategy?: 'crash' | 'manual';
    }): Promise<Agent>;
    private findLastSfp;
    private findSealedTools;
    history(opts?: {
        since?: number;
        limit?: number;
    }): Promise<AgentEvent[]>;
    status(): Promise<AgentStatus>;
    info(): Promise<AgentInfo>;
    use(hooks: Hooks): this;
    getHooks(): ReadonlyArray<import('./hooks').RegisteredHook>;
    registerTools(tools: Tool[]): this;
    schedule(): Scheduler;
    on(event: 'permission_ask' | 'error' | 'messages_update', handler: (...args: any[]) => void): this;
    private step;
    private executeTools;
    private requestPermission;
    private getToolSchemas;
    private persistMessages;
}

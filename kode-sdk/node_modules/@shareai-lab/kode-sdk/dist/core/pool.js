"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AgentPool = void 0;
const agent_1 = require("../core/agent");
class AgentPool {
    constructor(opts) {
        this.agents = new Map();
        this.store = opts.store;
        this.maxAgents = opts.maxAgents || 50;
    }
    create(sessionId, templateOrOpts, overrides) {
        if (this.agents.has(sessionId)) {
            throw new Error(`Agent already exists: ${sessionId}`);
        }
        if (this.agents.size >= this.maxAgents) {
            throw new Error(`Pool is full (max ${this.maxAgents} agents)`);
        }
        const agent = new agent_1.Agent(templateOrOpts, overrides);
        this.agents.set(sessionId, agent);
        return agent;
    }
    get(sessionId) {
        return this.agents.get(sessionId);
    }
    list(opts) {
        const ids = Array.from(this.agents.keys());
        return opts?.prefix ? ids.filter((id) => id.startsWith(opts.prefix)) : ids;
    }
    async status(sessionId) {
        const agent = this.agents.get(sessionId);
        return agent ? await agent.status() : undefined;
    }
    async fork(sessionId, snapshotSel) {
        const agent = this.agents.get(sessionId);
        if (!agent) {
            throw new Error(`Agent not found: ${sessionId}`);
        }
        return agent.fork(snapshotSel);
    }
    async resume(sessionId, opts) {
        // 1. Check if already in pool
        if (this.agents.has(sessionId)) {
            return this.agents.get(sessionId);
        }
        // 2. Check pool capacity
        if (this.agents.size >= this.maxAgents) {
            throw new Error(`Pool is full (max ${this.maxAgents} agents)`);
        }
        // 3. Verify session exists
        const exists = await this.store.exists(sessionId);
        if (!exists) {
            throw new Error(`Session not found in store: ${sessionId}`);
        }
        // 4. Use Agent.resume() to restore
        const agent = await agent_1.Agent.resume(sessionId, {
            ...opts,
            sessionId,
            store: this.store,
        });
        // 5. Add to pool
        this.agents.set(sessionId, agent);
        return agent;
    }
    async resumeAll(configFactory, opts) {
        const sessionIds = await this.store.list();
        const resumed = [];
        for (const sessionId of sessionIds) {
            if (this.agents.size >= this.maxAgents)
                break;
            if (this.agents.has(sessionId))
                continue;
            try {
                const config = configFactory(sessionId);
                const agent = await this.resume(sessionId, { ...config, ...opts });
                resumed.push(agent);
            }
            catch (error) {
                console.error(`Failed to resume ${sessionId}:`, error);
            }
        }
        return resumed;
    }
    async delete(sessionId) {
        this.agents.delete(sessionId);
        await this.store.delete(sessionId);
    }
    size() {
        return this.agents.size;
    }
}
exports.AgentPool = AgentPool;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalSandbox = void 0;
class LocalSandbox {
    constructor(opts) {
        this.kind = 'local';
        // Support workDir, baseDir (deprecated), and pwd (alias) for backward compatibility
        this.workDir = require('path').resolve(opts.workDir || opts.baseDir || opts.pwd || process.cwd());
        this.fs = new LocalFS(this.workDir);
    }
    async exec(cmd, opts) {
        const { exec } = require('child_process');
        const util = require('util');
        const execPromise = util.promisify(exec);
        const timeout = opts?.timeoutMs || 120000;
        try {
            const { stdout, stderr } = await execPromise(cmd, {
                cwd: this.workDir,
                timeout,
                maxBuffer: 10 * 1024 * 1024,
            });
            return { code: 0, stdout: stdout || '', stderr: stderr || '' };
        }
        catch (error) {
            return {
                code: error.code || 1,
                stdout: error.stdout || '',
                stderr: error.stderr || error.message || '',
            };
        }
    }
    static local(opts) {
        return new LocalSandbox(opts);
    }
}
exports.LocalSandbox = LocalSandbox;
class LocalFS {
    constructor(workDir) {
        this.workDir = workDir;
    }
    resolve(p) {
        const path = require('path');
        if (path.isAbsolute(p))
            return p;
        return path.resolve(this.workDir, p);
    }
    isInside(p) {
        const path = require('path');
        const resolved = this.resolve(p);
        const relative = path.relative(this.workDir, resolved);
        return !relative.startsWith('..') && !path.isAbsolute(relative);
    }
    async read(p) {
        const fs = require('fs').promises;
        const resolved = this.resolve(p);
        if (!this.isInside(resolved)) {
            throw new Error(`Path outside sandbox: ${p}`);
        }
        return await fs.readFile(resolved, 'utf-8');
    }
    async write(p, content) {
        const fs = require('fs').promises;
        const path = require('path');
        const resolved = this.resolve(p);
        if (!this.isInside(resolved)) {
            throw new Error(`Path outside sandbox: ${p}`);
        }
        const dir = path.dirname(resolved);
        await fs.mkdir(dir, { recursive: true });
        await fs.writeFile(resolved, content, 'utf-8');
    }
    temp(name) {
        const path = require('path');
        const tempName = name || `temp-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
        return path.relative(this.workDir, path.join(this.workDir, '.temp', tempName));
    }
}

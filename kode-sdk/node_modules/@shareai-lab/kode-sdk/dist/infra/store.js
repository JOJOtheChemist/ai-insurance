"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.JSONStore = void 0;
class JSONStore {
    constructor(baseDir) {
        this.baseDir = baseDir;
    }
    getPath(sessionId, file) {
        const fs = require('fs');
        const path = require('path');
        const dir = path.join(this.baseDir, sessionId);
        if (!fs.existsSync(dir)) {
            fs.mkdirSync(dir, { recursive: true });
        }
        return path.join(dir, file);
    }
    async saveMessages(sessionId, messages) {
        const fs = require('fs').promises;
        await fs.writeFile(this.getPath(sessionId, 'messages.json'), JSON.stringify(messages, null, 2));
    }
    async loadMessages(sessionId) {
        const fs = require('fs').promises;
        try {
            const data = await fs.readFile(this.getPath(sessionId, 'messages.json'), 'utf-8');
            return JSON.parse(data);
        }
        catch {
            return [];
        }
    }
    async appendEvent(sessionId, timeline) {
        const fs = require('fs').promises;
        const path = this.getPath(sessionId, 'events.jsonl');
        await fs.appendFile(path, JSON.stringify(timeline) + '\n');
    }
    async *readEvents(sessionId, since) {
        const fs = require('fs').promises;
        try {
            const data = await fs.readFile(this.getPath(sessionId, 'events.jsonl'), 'utf-8');
            const events = data
                .trim()
                .split('\n')
                .filter((line) => line)
                .map((line) => JSON.parse(line));
            const filtered = since !== undefined ? events.filter((e) => e.cursor >= since) : events;
            for (const event of filtered) {
                yield event;
            }
        }
        catch {
            // No events file, return empty
            return;
        }
    }
    async saveSnapshot(sessionId, snapshot) {
        const fs = require('fs').promises;
        const path = this.getPath(sessionId, `snapshot-${snapshot.id}.json`);
        await fs.writeFile(path, JSON.stringify(snapshot, null, 2));
    }
    async loadSnapshot(sessionId, snapshotId) {
        const fs = require('fs').promises;
        try {
            const data = await fs.readFile(this.getPath(sessionId, `snapshot-${snapshotId}.json`), 'utf-8');
            return JSON.parse(data);
        }
        catch {
            return undefined;
        }
    }
    async listSnapshots(sessionId) {
        const fs = require('fs').promises;
        const path = require('path');
        try {
            const dir = path.join(this.baseDir, sessionId);
            const files = await fs.readdir(dir);
            const snapshots = [];
            for (const file of files) {
                if (file.startsWith('snapshot-') && file.endsWith('.json')) {
                    const data = await fs.readFile(path.join(dir, file), 'utf-8');
                    snapshots.push(JSON.parse(data));
                }
            }
            return snapshots;
        }
        catch {
            return [];
        }
    }
    async saveInfo(sessionId, info) {
        const fs = require('fs').promises;
        await fs.writeFile(this.getPath(sessionId, 'info.json'), JSON.stringify(info, null, 2));
    }
    async loadInfo(sessionId) {
        const fs = require('fs').promises;
        try {
            const data = await fs.readFile(this.getPath(sessionId, 'info.json'), 'utf-8');
            return JSON.parse(data);
        }
        catch {
            return undefined;
        }
    }
    async exists(sessionId) {
        const fs = require('fs').promises;
        const path = require('path');
        try {
            await fs.access(path.join(this.baseDir, sessionId));
            return true;
        }
        catch {
            return false;
        }
    }
    async delete(sessionId) {
        const fs = require('fs').promises;
        const path = require('path');
        const dir = path.join(this.baseDir, sessionId);
        await fs.rm(dir, { recursive: true, force: true });
    }
    async list(prefix) {
        const fs = require('fs').promises;
        const path = require('path');
        try {
            const dirs = await fs.readdir(this.baseDir);
            return prefix ? dirs.filter((d) => d.startsWith(prefix)) : dirs;
        }
        catch {
            return [];
        }
    }
}
exports.JSONStore = JSONStore;

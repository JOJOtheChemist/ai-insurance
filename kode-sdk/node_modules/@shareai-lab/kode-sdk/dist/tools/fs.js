"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FsEdit = exports.FsWrite = exports.FsRead = void 0;
exports.toolTune = toolTune;
class FsRead {
    constructor() {
        this.name = 'fs_read';
        this.description = 'Read contents from a file';
        this.input_schema = {
            type: 'object',
            properties: {
                path: { type: 'string', description: 'Path to file' },
                offset: { type: 'number', description: 'Line offset (optional)' },
                limit: { type: 'number', description: 'Max lines to read (optional)' },
            },
            required: ['path'],
        };
    }
    async exec(args, ctx) {
        const content = await ctx.sandbox.fs.read(args.path);
        const lines = content.split('\n');
        const offset = args.offset || 0;
        const limit = args.limit || lines.length;
        const selected = lines.slice(offset, offset + limit);
        return selected.join('\n');
    }
}
exports.FsRead = FsRead;
class FsWrite {
    constructor() {
        this.name = 'fs_write';
        this.description = 'Write contents to a file (creates or overwrites)';
        this.input_schema = {
            type: 'object',
            properties: {
                path: { type: 'string', description: 'Path to file' },
                content: { type: 'string', description: 'Content to write' },
            },
            required: ['path', 'content'],
        };
    }
    async exec(args, ctx) {
        await ctx.sandbox.fs.write(args.path, args.content);
        const bytes = Buffer.byteLength(args.content, 'utf8');
        return `Wrote ${bytes} bytes to ${args.path}`;
    }
}
exports.FsWrite = FsWrite;
class FsEdit {
    constructor() {
        this.name = 'fs_edit';
        this.description = 'Edit a file by replacing old_string with new_string';
        this.input_schema = {
            type: 'object',
            properties: {
                path: { type: 'string', description: 'Path to file' },
                old_string: { type: 'string', description: 'String to replace' },
                new_string: { type: 'string', description: 'Replacement string' },
                replace_all: { type: 'boolean', description: 'Replace all occurrences (default: false)' },
            },
            required: ['path', 'old_string', 'new_string'],
        };
    }
    async exec(args, ctx) {
        const content = await ctx.sandbox.fs.read(args.path);
        if (args.replace_all) {
            const updated = content.split(args.old_string).join(args.new_string);
            await ctx.sandbox.fs.write(args.path, updated);
            const count = content.split(args.old_string).length - 1;
            return `Replaced ${count} occurrence(s) in ${args.path}`;
        }
        else {
            const occurrences = content.split(args.old_string).length - 1;
            if (occurrences === 0) {
                throw new Error(`old_string not found in ${args.path}`);
            }
            if (occurrences > 1) {
                throw new Error(`old_string appears ${occurrences} times; use replace_all=true or provide unique string`);
            }
            const updated = content.replace(args.old_string, args.new_string);
            await ctx.sandbox.fs.write(args.path, updated);
            return `Replaced 1 occurrence in ${args.path}`;
        }
    }
}
exports.FsEdit = FsEdit;
function toolTune(tool, hooks) {
    return {
        name: tool.name,
        description: tool.description,
        input_schema: tool.input_schema,
        exec: tool.exec.bind(tool),
        hooks: {
            ...tool.hooks,
            preToolUse: hooks.preToolUse,
            postToolUse: hooks.postToolUse,
        },
        permissionDetails: hooks.permissionDetails || tool.permissionDetails,
    };
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BashKill = exports.BashLogs = exports.BashRun = void 0;
const processes = new Map();
class BashRun {
    constructor() {
        this.name = 'bash_run';
        this.description = 'Execute a bash command';
        this.input_schema = {
            type: 'object',
            properties: {
                cmd: { type: 'string', description: 'Command to execute' },
                timeout_ms: { type: 'number', description: 'Timeout in milliseconds (default: 120000)' },
                background: { type: 'boolean', description: 'Run in background and return shell_id' },
            },
            required: ['cmd'],
        };
    }
    async exec(args, ctx) {
        if (args.background) {
            const id = `shell-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
            const promise = ctx.sandbox.exec(args.cmd, { timeoutMs: args.timeout_ms });
            const proc = {
                id,
                cmd: args.cmd,
                startTime: Date.now(),
                promise,
                stdout: '',
                stderr: '',
            };
            processes.set(id, proc);
            promise.then((result) => {
                proc.code = result.code;
                proc.stdout = result.stdout;
                proc.stderr = result.stderr;
            });
            return `Background shell started: ${id}`;
        }
        else {
            const result = await ctx.sandbox.exec(args.cmd, { timeoutMs: args.timeout_ms });
            const output = [result.stdout, result.stderr].filter(Boolean).join('\n').trim();
            return output || '(no output)';
        }
    }
}
exports.BashRun = BashRun;
class BashLogs {
    constructor() {
        this.name = 'bash_logs';
        this.description = 'Get output from a background bash shell';
        this.input_schema = {
            type: 'object',
            properties: {
                shell_id: { type: 'string', description: 'Shell ID from bash_run' },
            },
            required: ['shell_id'],
        };
    }
    async exec(args, ctx) {
        const proc = processes.get(args.shell_id);
        if (!proc) {
            throw new Error(`Shell not found: ${args.shell_id}`);
        }
        const isRunning = proc.code === undefined;
        const status = isRunning ? 'running' : `completed (exit code ${proc.code})`;
        const output = [proc.stdout, proc.stderr].filter(Boolean).join('\n').trim();
        return `Shell ${args.shell_id}: ${status}\n${output || '(no output yet)'}`;
    }
}
exports.BashLogs = BashLogs;
class BashKill {
    constructor() {
        this.name = 'bash_kill';
        this.description = 'Kill a background bash shell';
        this.input_schema = {
            type: 'object',
            properties: {
                shell_id: { type: 'string', description: 'Shell ID from Bash.Run' },
            },
            required: ['shell_id'],
        };
    }
    async exec(args, ctx) {
        const proc = processes.get(args.shell_id);
        if (!proc) {
            throw new Error(`Shell not found: ${args.shell_id}`);
        }
        processes.delete(args.shell_id);
        return `Killed shell ${args.shell_id}`;
    }
}
exports.BashKill = BashKill;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRun = void 0;
class TaskRun {
    constructor(subAgents) {
        this.subAgents = subAgents;
        this.name = 'task_run';
        this.description = 'Delegate a task to a sub-agent';
        this.input_schema = {
            type: 'object',
            properties: {
                task: { type: 'string', description: 'Task description for the sub-agent' },
                with: { type: 'string', description: 'Template ID to use (optional, will auto-select if omitted)' },
                context: { type: 'string', description: 'Additional context (optional)' },
            },
            required: ['task'],
        };
    }
    async exec(args, ctx) {
        // This will be implemented when Agent class is ready
        // For now, return a placeholder
        const template = args.with
            ? this.subAgents.find((t) => t.id === args.with)
            : this.selectTemplate(args.task);
        if (!template) {
            throw new Error(`Template not found: ${args.with || 'auto'}`);
        }
        return {
            status: 'delegated',
            template: template.id,
            task: args.task,
            note: 'Sub-agent execution will be implemented in Agent class',
        };
    }
    selectTemplate(task) {
        // Simple heuristic selection based on whenToUse hints
        for (const template of this.subAgents) {
            if (template.whenToUse && task.toLowerCase().includes(template.whenToUse.toLowerCase())) {
                return template;
            }
        }
        return this.subAgents[0];
    }
}
exports.TaskRun = TaskRun;
